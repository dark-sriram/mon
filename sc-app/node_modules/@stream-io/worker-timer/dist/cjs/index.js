"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerTimer = void 0;
const logger_1 = require("@stream-io/logger");
const worker_build_1 = require("./worker.build");
class WorkerTimer {
    /**
     * Constructs a new instance of WorkerTimer.
     *
     * @param init the init parameters.
     */
    constructor(init = {}) {
        this.currentTimerId = 1;
        this.callbacks = new Map();
        this.fallback = false;
        this.setup = ({ useWorker = true, name = "@stream-io/worker-timer", } = {}) => {
            if (!useWorker) {
                this.fallback = true;
                return;
            }
            try {
                const source = worker_build_1.timerWorker.src;
                const blob = new Blob([source], {
                    type: "application/javascript; charset=utf-8",
                });
                const script = URL.createObjectURL(blob);
                this.worker = new Worker(script, { name });
                this.worker.addEventListener("message", (e) => {
                    const { type, id } = e.data;
                    if (type === "tick") {
                        this.callbacks.get(id)?.();
                    }
                });
            }
            catch (err) {
                (0, logger_1.getLogger)("timer-worker").error(err);
                this.fallback = true;
            }
        };
        this.destroy = () => {
            this.callbacks.clear();
            this.worker?.terminate();
            this.worker = undefined;
            this.fallback = false;
        };
        this.setInterval = (callback, timeout) => this.setTimer("setInterval", callback, timeout);
        this.clearInterval = (id) => {
            this.clearTimer("clearInterval", id);
        };
        this.setTimeout = (callback, timeout) => this.setTimer("setTimeout", callback, timeout);
        this.clearTimeout = (id) => {
            this.clearTimer("clearTimeout", id);
        };
        this.setTimer = (type, callback, timeout) => {
            if (!this.ready) {
                this.setup();
            }
            if (this.fallback) {
                return (type === "setTimeout" ? setTimeout : setInterval)(callback, timeout);
            }
            const id = this.getTimerId();
            this.callbacks.set(id, () => {
                callback();
                // Timeouts are one-off operations, so no need to keep callback reference
                // after timer has fired
                if (type === "setTimeout") {
                    this.callbacks.delete(id);
                }
            });
            this.sendMessage({ type, id, timeout });
            return id;
        };
        this.clearTimer = (type, id) => {
            if (!id) {
                return;
            }
            if (!this.ready) {
                this.setup();
            }
            if (this.fallback) {
                (type === "clearTimeout" ? clearTimeout : clearInterval)(id);
                return;
            }
            this.callbacks.delete(id);
            this.sendMessage({ type, id });
        };
        this.getTimerId = () => this.currentTimerId++;
        this.sendMessage = (message) => {
            if (!this.worker) {
                throw new Error("Cannot use timer worker before it's set up");
            }
            this.worker.postMessage(message);
        };
        this.setup(init);
    }
    get ready() {
        return this.fallback || Boolean(this.worker);
    }
}
exports.WorkerTimer = WorkerTimer;
//# sourceMappingURL=index.js.map